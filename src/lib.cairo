#[derive(Drop)]
enum FlowControl {
    Continue,
    InvalidInstruction,
    End,
    ECall,
    EBreak,
    URet,
    SRet,
    MRet,
    Wfi
}

#[derive(Drop)]
struct ELFLoader {
    format32: bool, // true if 32 bit format
    little_endian: bool, // true if little endian
    e_entry: u32, // Program entry point
    e_phoff: u32, // Program header offset
    e_shoff: u32, // Section header offset
    e_flags: u32, // Flags
    e_ehsize: u16, // Header size
    e_phentsize: u16, // Program header size
    e_phnum: u16, // Program header count
    e_shentsize: u16, // Section header size
    e_shnum: u16, // Section header count
    e_shstrndx: u16, // Section header string table index
}

#[generate_trait]
impl ELFLoaderImpl of ELFLoaderTrait {
    fn new() -> ELFLoader {
        ELFLoader {
            format32: false,
            little_endian: false,
            e_entry: 0,
            e_phoff: 0,
            e_shoff: 0,
            e_flags: 0,
            e_ehsize: 0,
            e_phentsize: 0,
            e_phnum: 0,
            e_shentsize: 0,
            e_shnum: 0,
            e_shstrndx: 0,
        }
    }

    fn get_byte(ref self: ELFLoader, data: @Array<u8>, offset: u32) -> Option<u8> {
        match data.get(offset.into()) {
            Option::Some(v) => Option::Some(*v.unbox()),
            Option::None => Option::None,
        }
    }

    fn get_halfw(ref self: ELFLoader, data: @Array<u8>, offset: u32) -> Option<u16> {
        let offset = offset.into();
        let b1 = match self.get_byte(data, offset + 0) {
            Option::Some(v) => v,
            Option::None => { return Option::None; },
        };
        let b2 = match self.get_byte(data, offset + 1) {
            Option::Some(v) => v,
            Option::None => { return Option::None; },
        };
        if self.little_endian {
            // little endian, which means the least significant byte is first
            Option::Some(b1.into() + (b2.into() * 0b100000000))
        } else {
            // big endian, which means the most significant byte is first
            Option::Some(b2.into() + (b1.into() * 0b100000000))
        }
    }

    fn get_w(ref self: ELFLoader, data: @Array<u8>, offset: u32) -> Option<u32> {
        let offset = offset.into();
        let b1 = match self.get_byte(data, offset + 0) {
            Option::Some(v) => v,
            Option::None => { return Option::None; },
        };
        let b2 = match self.get_byte(data, offset + 1) {
            Option::Some(v) => v,
            Option::None => { return Option::None; },
        };
        let b3 = match self.get_byte(data, offset + 2) {
            Option::Some(v) => v,
            Option::None => { return Option::None; },
        };
        let b4 = match self.get_byte(data, offset + 3) {
            Option::Some(v) => v,
            Option::None => { return Option::None; },
        };
        if self.little_endian {
            // little endian, which means the least significant byte is first
            Option::Some(
                b1.into()
                    + (b2.into() * 0b100000000)
                    + (b3.into() * 0b10000000000000000)
                    + (b4.into() * 0b1000000000000000000000000)
            )
        } else {
            // big endian, which means the most significant byte is first
            Option::Some(
                b4.into()
                    + (b3.into() * 0b100000000)
                    + (b2.into() * 0b10000000000000000)
                    + (b1.into() * 0b1000000000000000000000000)
            )
        }
    }

    fn load(ref self: ELFLoader, data: @Array<u8>, ref machine: RISCVMachine) -> bool {
        // parse elf header
        if !self.parse_elf_header(data, ref machine) {
            return false;
        }

        // parse section headers
        if !self.parse_section_headers(data, ref machine) {
            return false;
        }

        // parse program headers
        if !self.parse_program_headers(data, ref machine) {
            return false;
        }

        true
    }

    fn parse_section_headers(
        ref self: ELFLoader, data: @Array<u8>, ref machine: RISCVMachine
    ) -> bool {
        // The section headers start at e_shoff and are e_shnum in number, each with a size of e_shentsize.
        // The section header string table index is e_shstrndx.

        let mut section_index = 0;
        let mut offset = self.e_shoff;
        let mut res = true;

        loop {
            // check for termination
            if section_index == self.e_shnum {
                break;
            }

            // read section header

            // sh_name
            // An offset to a string in the .shstrtab section that represents the name of this section.
            let _sh_name = match self.get_w(data, offset + 0x00) {
                Option::Some(v) => v,
                Option::None => {
                    res = false;
                    break;
                },
            };

            // sh_type
            let _sh_type = match self.get_w(data, offset + 0x04) {
                Option::Some(v) => v,
                Option::None => {
                    res = false;
                    break;
                },
            };

            // sh_flags
            let _sh_flags = match self.get_w(data, offset + 0x08) {
                Option::Some(v) => v,
                Option::None => {
                    res = false;
                    break;
                },
            };

            // sh_addr
            let sh_addr = match self.get_w(data, offset + 0x0C) {
                Option::Some(v) => v,
                Option::None => {
                    res = false;
                    break;
                },
            };

            // sh_offset
            let sh_offset = match self.get_w(data, offset + 0x10) {
                Option::Some(v) => v,
                Option::None => {
                    res = false;
                    break;
                },
            };

            // sh_size
            let sh_size = match self.get_w(data, offset + 0x14) {
                Option::Some(v) => v,
                Option::None => {
                    res = false;
                    break;
                },
            };

            // sh_link
            let _sh_link = match self.get_w(data, offset + 0x18) {
                Option::Some(v) => v,
                Option::None => {
                    res = false;
                    break;
                },
            };

            // sh_info
            let _sh_info = match self.get_w(data, offset + 0x1C) {
                Option::Some(v) => v,
                Option::None => {
                    res = false;
                    break;
                },
            };

            // sh_addralign
            let _sh_addralign = match self.get_w(data, offset + 0x20) {
                Option::Some(v) => v,
                Option::None => {
                    res = false;
                    break;
                },
            };

            // sh_entsize
            let _sh_entsize = match self.get_w(data, offset + 0x24) {
                Option::Some(v) => v,
                Option::None => {
                    res = false;
                    break;
                },
            };

            // load section into memory
            let mut file_cursor = sh_offset;
            let mut mem_cursor = sh_addr;
            loop {
                if file_cursor >= sh_offset + sh_size {
                    break;
                }

                let entry = match self.get_byte(data, file_cursor) {
                    Option::Some(v) => v,
                    Option::None => {
                        res = false;
                        break;
                    },
                };

                machine.mem_set(mem_cursor, entry);

                file_cursor += 1;
                mem_cursor += 1;
            };
            if res == false {
                break;
            }

            // update cursor
            section_index += 1;
            offset += self.e_shentsize.into();
        };

        res
    }

    fn parse_program_headers(
        ref self: ELFLoader, data: @Array<u8>, ref machine: RISCVMachine
    ) -> bool {
        // The program header table tells the system how to create a process image.
        // It is found at file offset e_phoff, and consists of e_phnum entries, each with size e_phentsize.

        let mut prog_index = 0;
        let mut offset = self.e_phoff;
        let mut res = true;
        loop {
            // check for termination
            if prog_index == self.e_phnum {
                break;
            }

            // read program header

            // type
            match self.get_w(data, offset + 0x00) {
                Option::Some(v) => {
                    if v == 0x00000001 { // PT_LOAD
                    // this is a loadable segment
                    } else {
                        // ignore non-loadable segments
                        continue;
                    }
                },
                Option::None => {
                    res = false;
                    break;
                },
            };

            // Offset of the segment in the file image
            let p_offset = match self.get_w(data, offset + 0x04) {
                Option::Some(v) => v,
                Option::None => {
                    res = false;
                    break;
                },
            };

            // Virtual address of the segment in memory
            let p_vaddr = match self.get_w(data, offset + 0x08) {
                Option::Some(v) => v,
                Option::None => {
                    res = false;
                    break;
                },
            };

            // Physical address
            let _p_paddr = match self.get_w(data, offset + 0x0C) {
                Option::Some(v) => v,
                Option::None => {
                    res = false;
                    break;
                },
            };

            // Size of the segment in the file image
            let p_filesz = match self.get_w(data, offset + 0x10) {
                Option::Some(v) => v,
                Option::None => {
                    res = false;
                    break;
                },
            };

            // Size of the segment in memory
            let p_memsz = match self.get_w(data, offset + 0x14) {
                Option::Some(v) => v,
                Option::None => {
                    res = false;
                    break;
                },
            };

            // set program end
            machine.set_prog_end(wrap_add(p_vaddr, p_memsz));

            // Flags
            let _p_flags = match self.get_w(data, offset + 0x18) {
                Option::Some(v) => v,
                Option::None => {
                    res = false;
                    break;
                },
            };

            // Alignment
            let _p_align = match self.get_w(data, offset + 0x1C) {
                Option::Some(v) => v,
                Option::None => {
                    res = false;
                    break;
                },
            };

            // Load segment into machine memory
            let mut file_cursor = p_offset;
            let mut mem_cursor = p_vaddr;
            loop {
                if file_cursor >= p_offset + p_filesz {
                    break;
                }

                let entry = match self.get_byte(data, file_cursor) {
                    Option::Some(v) => v,
                    Option::None => {
                        res = false;
                        break;
                    },
                };

                machine.mem_set(mem_cursor, entry);

                file_cursor += 1;
                mem_cursor += 1;
            };
            if res == false {
                break;
            }

            // update cursor
            prog_index += 1;
            offset += self.e_phentsize.into();
        };
        res
    }

    fn parse_elf_header(ref self: ELFLoader, data: @Array<u8>, ref machine: RISCVMachine) -> bool {
        // magic
        match self.get_byte(data, 0x00 + 0) {
            Option::Some(v) => { if v != 0x7F {
                return false;
            } },
            Option::None => { return false; },
        }
        match self.get_byte(data, 0x00 + 1) {
            Option::Some(v) => { if v != 0x45 {
                return false;
            } },
            Option::None => { return false; },
        }
        match self.get_byte(data, 0x00 + 2) {
            Option::Some(v) => { if v != 0x4c {
                return false;
            } },
            Option::None => { return false; },
        }
        match self.get_byte(data, 0x00 + 3) {
            Option::Some(v) => { if v != 0x46 {
                return false;
            } },
            Option::None => { return false; },
        }

        // bit depth
        match self.get_byte(data, 0x04) {
            Option::Some(v) => {
                if v == 1 {
                    // 32-bit
                    self.format32 = true;
                } else if v == 2 {
                    // 64-bit
                    self.format32 = false;
                    // unsupported for now
                    return false;
                } else {
                    return false;
                }
            },
            Option::None => { return false; },
        }

        // endianness
        match self.get_byte(data, 0x05) {
            Option::Some(v) => {
                if v == 1 {
                    // litte endian
                    self.little_endian = true;
                } else if v == 2 {
                    // big endian
                    self.little_endian = false;
                } else {
                    return false;
                }
            },
            Option::None => { return false; },
        }

        // version
        match self.get_byte(data, 0x06) {
            Option::Some(v) => { if v != 1 {
                return false;
            } },
            Option::None => { return false; },
        }

        // OS ABI
        match self.get_byte(data, 0x07) {
            Option::Some(v) => { if v != 0 {
                return false;
            } },
            Option::None => { return false; },
        }

        // Ignore OS ABI version at 0x08

        // Ignore padding at 0x09

        // Type
        match self.get_halfw(data, 0x10) {
            Option::Some(v) => {
                if v != 0x02 {
                    // unsupported elf type (only ET_EXEC=0x02 is supported)
                    return false;
                }
            },
            Option::None => { return false; },
        }

        // Machine
        match self.get_halfw(data, 0x12) {
            Option::Some(v) => {
                if v != 0xF3 {
                    // unsupported machine (only EM_RISCV=0xF3 is supported)
                    return false;
                }
            },
            Option::None => { return false; },
        }

        // Version
        match self.get_w(data, 0x14) {
            Option::Some(v) => { if v != 1 {
                return false;
            } },
            Option::None => { return false; },
        }

        // Entry point
        self.e_entry = match self.get_w(data, 0x18) {
            Option::Some(v) => v,
            Option::None => { return false; },
        };
        machine.set_pc(self.e_entry);

        // Program header offset
        self.e_phoff = match self.get_w(data, 0x1C) {
            Option::Some(v) => v,
            Option::None => { return false; },
        };

        // Section header offset
        self.e_shoff = match self.get_w(data, 0x20) {
            Option::Some(v) => v,
            Option::None => { return false; },
        };

        // Flags
        self.e_flags = match self.get_w(data, 0x24) {
            Option::Some(v) => v,
            Option::None => { return false; },
        };

        // Header size
        self.e_ehsize = match self.get_halfw(data, 0x28) {
            Option::Some(v) => v,
            Option::None => { return false; },
        };

        // Program header size
        self.e_phentsize = match self.get_halfw(data, 0x2A) {
            Option::Some(v) => v,
            Option::None => { return false; },
        };

        // Program header count
        self.e_phnum = match self.get_halfw(data, 0x2C) {
            Option::Some(v) => v,
            Option::None => { return false; },
        };

        // Section header size
        self.e_shentsize = match self.get_halfw(data, 0x2E) {
            Option::Some(v) => v,
            Option::None => { return false; },
        };

        // Section header count
        self.e_shnum = match self.get_halfw(data, 0x30) {
            Option::Some(v) => v,
            Option::None => { return false; },
        };

        // Section header string table index
        self.e_shstrndx = match self.get_halfw(data, 0x32) {
            Option::Some(v) => v,
            Option::None => { return false; },
        };

        true
    }
}

struct RISCVMachine {
    // r0 is hardcoded to 0
    r1: u32,
    r2: u32,
    r3: u32,
    r4: u32,
    r5: u32,
    r6: u32,
    r7: u32,
    r8: u32,
    r9: u32,
    r10: u32,
    r11: u32,
    r12: u32,
    r13: u32,
    r14: u32,
    r15: u32,
    r16: u32,
    r17: u32,
    r18: u32,
    r19: u32,
    r20: u32,
    r21: u32,
    r22: u32,
    r23: u32,
    r24: u32,
    r25: u32,
    r26: u32,
    r27: u32,
    r28: u32,
    r29: u32,
    r30: u32,
    r31: u32,
    pc: u32,
    prog_end: u32, // when pc reaches this value, the program ends
    mem: Felt252Dict<u8>,
    csrs: Felt252Dict<u32>,
}

impl RISCVMachineDestruct of Destruct<RISCVMachine> {
    fn destruct(self: RISCVMachine) nopanic {
        self.mem.squash();
        self.csrs.squash();
    }
}

// Warning: divisions in cairo are not rounding the same way as in other languages, so avoid any case of rounding by only doing exact divisions

// decode an u-type instuction
// returns (rd, imm)
fn decode_uinstr(instr: u32) -> (u32, u32) {
    // bits 31-12 of the immediate value (bits 31-12 of the instruction)
    let imm: u32 = instr & 0b11111111111111111111000000000000;

    // destination register (bits 11-7 of the instruction)
    let rd = (instr & 0b111110000000) / 0b10000000;

    (rd, imm)
}

// decode an i-type instuction
// returns (rd, rs1, imm)
fn decode_iinstr(instr: u32) -> (u32, u32, u32) {
    // bits 11-0 of the immediate value (bits 31-20 of the instruction)
    let imm: u32 = (instr & 0b11111111111100000000000000000000) / 0b100000000000000000000;

    // rs1 register (bits 19-15 of the instruction)
    let rs1 = (instr & 0b11111000000000000000) / 0b1000000000000000;

    // destination register (bits 11-7 of the instruction)
    let rd = (instr & 0b111110000000) / 0b10000000;

    (rd, rs1, imm)
}

// decode an r-type instuction
// returns (rd, rs1, rs2)
fn decode_rinstr(instr: u32) -> (u32, u32, u32) {
    // rs2 register (bits 24-20 of the instruction)
    let rs2 = (instr & 0b1111100000000000000000000) / 0b100000000000000000000;

    // rs1 register (bits 19-15 of the instruction)
    let rs1 = (instr & 0b11111000000000000000) / 0b1000000000000000;

    // destination register (bits 11-7 of the instruction)
    let rd = (instr & 0b111110000000) / 0b10000000;

    (rd, rs1, rs2)
}

// decode a j-type instuction
// returns (rd, imm)
fn decode_jinstr(instr: u32) -> (u32, u32) {
    let imm = ((instr & 0b10000000000000000000000000000000) / 0b100000000000) // bit 20
        + ((instr & 0b01111111111000000000000000000000) / 0b100000000000000000000) // bits 10-1
        + ((instr & 0b00000000000100000000000000000000) / 0b1000000000) // bit 11
        + ((instr & 0b00000000000011111111000000000000)); // bits 19-12

    // destination register (bits 11-7 of the instruction)
    let rd = (instr & 0b111110000000) / 0b10000000;

    (rd, imm)
}

// decode a b-type instuction
// returns (rs1, rs2, imm)
fn decode_binstr(instr: u32) -> (u32, u32, u32) {
    let imm = ((instr & 0b10000000000000000000000000000000) / 0b10000000000000000000) // bit 12
        + ((instr & 0b01111110000000000000000000000000) / 0b100000000000000000000) // bits 10-5
        + ((instr & 0b00000000000000000000111100000000) / 0b10000000) // bits 4-1
        + ((instr & 0b00000000000000000000000010000000) * 0b10000); // bit 11

    // rs2 register (bits 24-20 of the instruction)
    let rs2 = (instr & 0b1111100000000000000000000) / 0b100000000000000000000;

    // rs1 register (bits 19-15 of the instruction)
    let rs1 = (instr & 0b11111000000000000000) / 0b1000000000000000;

    (rs1, rs2, imm)
}

// decode funct3 in an instruction
fn decode_funct3(instr: u32) -> u32 {
    // bits 14-12 of the instruction
    (instr & 0b111000000000000) / 0b1000000000000
}

// decode funct7 in an instruction
fn decode_funct7(instr: u32) -> u32 {
    // bits 31-25 of the instruction
    (instr & 0b11111110000000000000000000000000) / 0b10000000000000000000000000
}

// sign-extend a 21-bit value to 32 bits
fn sext21(input: u32) -> u32 {
    if (input & 0b100000000000000000000) != 0 {
        // negative
        input | 0b11111111111100000000000000000000
    } else {
        // positive
        input & 0b00000000000011111111111111111111
    }
}

// sign-extend a 12-bit value to 32 bits
fn sext12(input: u32) -> u32 {
    if (input & 0b100000000000) != 0 {
        // negative
        input | 0b11111111111111111111100000000000
    } else {
        // positive
        input & 0b00000000000000000000011111111111
    }
}

// sign-extend a 13-bit value to 32 bits
fn sext13(input: u32) -> u32 {
    if (input & 0b1000000000000) != 0 {
        // negative
        input | 0b11111111111111111111000000000000
    } else {
        // positive
        input & 0b00000000000000000000111111111111
    }
}

// sign-extend a 16-bit value to 32 bits
fn sext16(input: u32) -> u32 {
    if (input & 0b1000000000000000) != 0 {
        // negative
        input | 0b11111111111111111000000000000000
    } else {
        // positive
        input & 0b00000000000000000111111111111111
    }
}

// sign-extend a 8-bit value to 32 bits
fn sext8(input: u32) -> u32 {
    if (input & 0b10000000) != 0 {
        // negative
        input | 0b11111111111111111111111110000000
    } else {
        // positive
        input & 0b00000000000000000000000001111111
    }
}

// Interprets a raw u32 (typically a register) as being a 2-complement encoded i32
fn decode_signed(input: u32) -> i32 {
    if (input & 0b10000000000000000000000000000000) != 0 {
        // negative: sign-extend
        let tmp_i64: i64 = -(0b100000000000000000000000000000000 - input.into());
        tmp_i64.try_into().unwrap()
    } else {
        // positive
        input.try_into().unwrap()
    }
}

// Encodes a i32 into a raw u32 format using 2-complement 
fn encode_signed(input: i32) -> u32 {
    if input >= 0 {
        // positive: simply cast
        input.try_into().unwrap()
    } else {
        // negative: 2-complement encoding
        let tmp_i64: i64 = 0b100000000000000000000000000000000 + input.into();
        tmp_i64.try_into().unwrap()
    }
}

// wrapping 32-bit addition
fn wrap_add(a: u32, b: u32) -> u32 {
    let tmp: u64 = a.into() + b.into();
    if tmp > 0xFFFFFFFF {
        (tmp - 0b100000000000000000000000000000000).try_into().unwrap()
    } else {
        tmp.try_into().unwrap()
    }
}

// wrapping 32-bit subtraction
fn wrap_sub(a: u32, b: u32) -> u32 {
    let tmp: i64 = a.into() - b.into();
    if tmp < 0 {
        // negative: wrap
        (tmp + 0b100000000000000000000000000000000).try_into().unwrap()
    } else {
        // positive: return
        tmp.try_into().unwrap()
    }
}

// raw bit shift left
fn shl(mut v: u32, mut shift: u32) -> u32 {
    while shift != 0 {
        v = (v & 0b01111111111111111111111111111111) * 2;
        shift -= 1;
    };
    v
}

// raw bit shift right
fn shr(mut v: u32, mut shift: u32) -> u32 {
    while shift != 0 {
        v = (v & 0b01111111111111111111111111111110) / 2;
        shift -= 1;
    };
    v
}

// arithmetic bit shift right
fn shrs(mut v: u32, mut shift: u32) -> u32 {
    while shift != 0 {
        let high_bit = v & 0b10000000000000000000000000000000;
        v = ((v & 0b11111111111111111111111111111110) / 2) | high_bit;
        shift -= 1;
    };
    v
}

// arithmetic bit shift left
fn shls(mut v: u32, mut shift: u32) -> u32 {
    while shift != 0 {
        let high_bit = v & 0b10000000000000000000000000000000;
        v = ((v & 0b00111111111111111111111111111111) * 2) | high_bit;
        shift -= 1;
    };
    v
}

// convert u32 to little-endian representation
fn to_le(v: u32) -> u32 {
    // most significant byte is b0
    let b0 = (v & 0b11111111000000000000000000000000) / 0b1000000000000000000000000;
    let b1 = (v & 0b00000000111111110000000000000000) / 0b10000000000000000;
    let b2 = (v & 0b00000000000000001111111100000000) / 0b100000000;
    let b3 = (v & 0b00000000000000000000000011111111);

    // put the most significant byte last in the generated number
    b0 + (b1 * 0b100000000) + (b2 * 0b10000000000000000) + (b3 * 0b1000000000000000000000000)
}

// parse an u32 from its little-endian representation
fn from_le(v: u32) -> u32 {
    // most significant byte is b0
    let b3 = (v & 0b11111111000000000000000000000000) / 0b1000000000000000000000000;
    let b2 = (v & 0b00000000111111110000000000000000) / 0b10000000000000000;
    let b1 = (v & 0b00000000000000001111111100000000) / 0b100000000;
    let b0 = (v & 0b00000000000000000000000011111111);

    // put the most significant byte last in the generated number
    b3 + (b2 * 0b100000000) + (b1 * 0b10000000000000000) + (b0 * 0b1000000000000000000000000)
}

#[generate_trait]
impl RISCVMachineImpl of RISCVMachineTrait {
    fn new() -> RISCVMachine {
        RISCVMachine {
            r1: 0,
            r2: 0,
            r3: 0,
            r4: 0,
            r5: 0,
            r6: 0,
            r7: 0,
            r8: 0,
            r9: 0,
            r10: 0,
            r11: 0,
            r12: 0,
            r13: 0,
            r14: 0,
            r15: 0,
            r16: 0,
            r17: 0,
            r18: 0,
            r19: 0,
            r20: 0,
            r21: 0,
            r22: 0,
            r23: 0,
            r24: 0,
            r25: 0,
            r26: 0,
            r27: 0,
            r28: 0,
            r29: 0,
            r30: 0,
            r31: 0,
            pc: 0,
            prog_end: 0,
            mem: Default::default(),
            csrs: Default::default(),
        }
    }

    fn mem_get(ref self: RISCVMachine, offset: u32) -> u8 {
        self.mem.get(offset.into())
    }

    fn mem_set(ref self: RISCVMachine, offset: u32, value: u8) {
        self.mem.insert(offset.into(), value);
    }

    fn get_pc(ref self: RISCVMachine) -> u32 {
        self.pc
    }

    fn set_pc(ref self: RISCVMachine, pc: u32) {
        self.pc = pc;
    }

    // get a register value
    fn get_r(ref self: RISCVMachine, r: u32) -> Option<u32> {
        Option::Some(
            match r {
                0 => 0, // r0 is hardcoded to 0
                1 => self.r1.clone(),
                2 => self.r2.clone(),
                3 => self.r3.clone(),
                4 => self.r4.clone(),
                5 => self.r5.clone(),
                6 => self.r6.clone(),
                7 => self.r7.clone(),
                8 => self.r8.clone(),
                9 => self.r9.clone(),
                10 => self.r10.clone(),
                11 => self.r11.clone(),
                12 => self.r12.clone(),
                13 => self.r13.clone(),
                14 => self.r14.clone(),
                15 => self.r15.clone(),
                16 => self.r16.clone(),
                17 => self.r17.clone(),
                18 => self.r18.clone(),
                19 => self.r19.clone(),
                20 => self.r20.clone(),
                21 => self.r21.clone(),
                22 => self.r22.clone(),
                23 => self.r23.clone(),
                24 => self.r24.clone(),
                25 => self.r25.clone(),
                26 => self.r26.clone(),
                27 => self.r27.clone(),
                28 => self.r28.clone(),
                29 => self.r29.clone(),
                30 => self.r30.clone(),
                31 => self.r31.clone(),
                _ => { return Option::None; },
            }
        )
    }

    // set a register value
    fn set_r(ref self: RISCVMachine, r: u32, value: u32) -> bool {
        match r {
            0 => {}, // r0 is hardcoded to 0
            1 => self.r1 = value,
            2 => self.r2 = value,
            3 => self.r3 = value,
            4 => self.r4 = value,
            5 => self.r5 = value,
            6 => self.r6 = value,
            7 => self.r7 = value,
            8 => self.r8 = value,
            9 => self.r9 = value,
            10 => self.r10 = value,
            11 => self.r11 = value,
            12 => self.r12 = value,
            13 => self.r13 = value,
            14 => self.r14 = value,
            15 => self.r15 = value,
            16 => self.r16 = value,
            17 => self.r17 = value,
            18 => self.r18 = value,
            19 => self.r19 = value,
            20 => self.r20 = value,
            21 => self.r21 = value,
            22 => self.r22 = value,
            23 => self.r23 = value,
            24 => self.r24 = value,
            25 => self.r25 = value,
            26 => self.r26 = value,
            27 => self.r27 = value,
            28 => self.r28 = value,
            29 => self.r29 = value,
            30 => self.r30 = value,
            31 => self.r31 = value,
            _ => { return false; },
        }
        true
    }

    // set prog_end
    fn set_prog_end(ref self: RISCVMachine, prog_end: u32) {
        self.prog_end = prog_end;
    }

    // get a CSR value
    // for now, no particular CSR is implemented and no access checks are done
    fn get_csr(ref self: RISCVMachine, csr: u32) -> Option<u32> {
        if csr > 0xFFF {
            // invalid CSR
            return Option::None;
        }
        Option::Some(self.csrs.get(csr.into()))
    }

    // set a CSR value
    // for now, no particular CSR is implemented and no access checks are done
    fn set_csr(ref self: RISCVMachine, csr: u32, value: u32) -> bool {
        if csr > 0xFFF {
            // invalid CSR
            return false;
        }
        if (csr & 0b110000000000) == 0b110000000000 {
            // this CSR is read-only
            if value != self.csrs.get(csr.into()) {
                // as such, its value should not change
                return false;
            }
        }
        self.csrs.insert(csr.into(), value);
        true
    }

    // returns true to halt
    fn execute_instr(ref self: RISCVMachine, instr: u32) -> FlowControl {
        // print the instruction in binary
        if (instr & 0b11 != 0b11) {
            return FlowControl::InvalidInstruction;
        }
        let mut return_v = FlowControl::Continue;
        match ((instr & 0b1111100) / 0b100) {
            0b00000 => {
                // memory load instructions
                let (rd, rs1, imm) = decode_iinstr(instr);
                let rs1_v = match self.get_r(rs1) {
                    Option::Some(v) => v,
                    Option::None => { return FlowControl::InvalidInstruction; },
                };
                let offset = sext12(imm);
                let outv = match decode_funct3(instr) {
                    0b000 => {
                        // lb
                        let base_offset = wrap_add(rs1_v, offset);
                        let b1: u32 = self.mem_get(base_offset).into();
                        sext8(b1)
                    },
                    0b001 => {
                        // lh
                        let base_offset = wrap_add(rs1_v, offset);
                        let b1: u32 = self.mem_get(base_offset).into();
                        let b2: u32 = self.mem_get(wrap_add(base_offset, 1)).into();
                        // little-endian means b1 is the least significant byte
                        let res = b1 + (b2 * 0b100000000);
                        sext16(res)
                    },
                    0b010 => {
                        // lw
                        let base_offset = wrap_add(rs1_v, offset);
                        let b1: u32 = self.mem_get(base_offset).into();
                        let b2: u32 = self.mem_get(wrap_add(base_offset, 1)).into();
                        let b3: u32 = self.mem_get(wrap_add(base_offset, 2)).into();
                        let b4: u32 = self.mem_get(wrap_add(base_offset, 3)).into();
                        // little-endian means b1 is the least significant byte
                        b1
                            + (b2 * 0b100000000)
                            + (b3 * 0b10000000000000000)
                            + (b4 * 0b1000000000000000000000000)
                    },
                    0b011 => { return FlowControl::InvalidInstruction; },
                    0b100 => {
                        // lbu
                        let base_offset = wrap_add(rs1_v, offset);
                        self.mem_get(base_offset).into()
                    },
                    0b101 => {
                        // lhu
                        let base_offset = wrap_add(rs1_v, offset);
                        let b1: u32 = self.mem_get(base_offset).into();
                        let b2: u32 = self.mem_get(wrap_add(base_offset, 1)).into();
                        b1 + (b2 * 0b100000000)
                    },
                    0b110 => { return FlowControl::InvalidInstruction; },
                    0b111 => { return FlowControl::InvalidInstruction; },
                    _ => { return FlowControl::InvalidInstruction; },
                };
                if !self.set_r(rd, outv) {
                    return FlowControl::InvalidInstruction;
                }
                self.pc = wrap_add(self.pc, 4);
            },
            0b00001 => { return FlowControl::InvalidInstruction; },
            0b00010 => { return FlowControl::InvalidInstruction; },
            0b00011 => {
                // fence / fence.i: ignore for now
                // TODO at least check validity in the future
                self.pc = wrap_add(self.pc, 4);
            },
            0b00100 => {
                match decode_funct3(instr) {
                    0b000 => {
                        // addi
                        let (rd, rs1, imm) = decode_iinstr(instr);
                        let rs1_v = match self.get_r(rs1) {
                            Option::Some(v) => v,
                            Option::None => { return FlowControl::InvalidInstruction; },
                        };
                        if !self.set_r(rd, wrap_add(rs1_v, sext12(imm))) {
                            return FlowControl::InvalidInstruction;
                        }
                    },
                    0b001 => {
                        // slli
                        let (rd, rs1, imm) = decode_iinstr(instr);
                        let shift = imm & 0b00000000000000000000000000011111;
                        // note: the 6th bit of imm is used only in RV64
                        let rs1_v = match self.get_r(rs1) {
                            Option::Some(v) => v,
                            Option::None => { return FlowControl::InvalidInstruction; },
                        };
                        if !self.set_r(rd, shl(rs1_v, shift)) {
                            return FlowControl::InvalidInstruction;
                        }
                    },
                    0b010 => {
                        // slti
                        let (rd, rs1, imm) = decode_iinstr(instr);
                        let rs1_v = match self.get_r(rs1) {
                            Option::Some(v) => v,
                            Option::None => { return FlowControl::InvalidInstruction; },
                        };
                        let res = if decode_signed(rs1_v) < decode_signed(sext12(imm)) {
                            1
                        } else {
                            0
                        };
                        if !self.set_r(rd, res) {
                            return FlowControl::InvalidInstruction;
                        }
                    },
                    0b011 => {
                        // sltiu
                        let (rd, rs1, imm) = decode_iinstr(instr);
                        let rs1_v = match self.get_r(rs1) {
                            Option::Some(v) => v,
                            Option::None => { return FlowControl::InvalidInstruction; },
                        };
                        let res = if rs1_v < sext12(imm) {
                            1
                        } else {
                            0
                        };
                        if !self.set_r(rd, res) {
                            return FlowControl::InvalidInstruction;
                        }
                    },
                    0b100 => {
                        // xori
                        let (rd, rs1, imm) = decode_iinstr(instr);
                        let rs1_v = match self.get_r(rs1) {
                            Option::Some(v) => v,
                            Option::None => { return FlowControl::InvalidInstruction; },
                        };
                        let res = rs1_v ^ sext12(imm);
                        if !self.set_r(rd, res) {
                            return FlowControl::InvalidInstruction;
                        }
                    },
                    0b101 => {
                        // binary shifts
                        let (rd, rs1, imm) = decode_iinstr(instr);
                        let subtype = (imm & 0b1111100000000000000000000000000)
                            / 0b100000000000000000000000000;
                        let shift = imm & 0b00000000000000000000000000011111;
                        // note: the 6th bit of imm is used only in RV64
                        let rs1_v = match self.get_r(rs1) {
                            Option::Some(v) => v,
                            Option::None => { return FlowControl::InvalidInstruction; },
                        };
                        let res = if subtype == 0b00000 {
                            // srli
                            shr(rs1_v, shift)
                        } else if subtype == 0b01000 {
                            // srai
                            shrs(rs1_v, shift)
                        } else {
                            return FlowControl::InvalidInstruction;
                        };
                        if !self.set_r(rd, res) {
                            return FlowControl::InvalidInstruction;
                        }
                    },
                    0b110 => {
                        // ori
                        let (rd, rs1, imm) = decode_iinstr(instr);
                        let rs1_v = match self.get_r(rs1) {
                            Option::Some(v) => v,
                            Option::None => { return FlowControl::InvalidInstruction; },
                        };
                        let res = rs1_v | sext12(imm);
                        if !self.set_r(rd, res) {
                            return FlowControl::InvalidInstruction;
                        }
                    },
                    0b111 => {
                        // andi
                        let (rd, rs1, imm) = decode_iinstr(instr);
                        let rs1_v = match self.get_r(rs1) {
                            Option::Some(v) => v,
                            Option::None => { return FlowControl::InvalidInstruction; },
                        };
                        let res = rs1_v & sext12(imm);
                        if !self.set_r(rd, res) {
                            return FlowControl::InvalidInstruction;
                        }
                    },
                    _ => { return FlowControl::InvalidInstruction; },
                }
                self.pc = wrap_add(self.pc, 4);
            },
            0b00101 => {
                // auipc
                let (rd, imm) = decode_uinstr(instr);
                if !self.set_r(rd, wrap_add(self.pc, imm)) {
                    return FlowControl::InvalidInstruction;
                }
                self.pc = wrap_add(self.pc, 4);
            },
            0b00110 => { return FlowControl::InvalidInstruction; },
            0b00111 => { return FlowControl::InvalidInstruction; },
            0b01000 => {
                // memory store instructions
                let offset_h = decode_funct7(instr);
                let funct3 = decode_funct3(instr);
                let (offset_l, rs1, rs2) = decode_rinstr(instr);
                let offset = sext12((offset_h * 0b100000) + offset_l);
                let rs1_v = match self.get_r(rs1) {
                    Option::Some(v) => v,
                    Option::None => { return FlowControl::InvalidInstruction; },
                };
                let rs2_v = match self.get_r(rs2) {
                    Option::Some(v) => v,
                    Option::None => { return FlowControl::InvalidInstruction; },
                };
                match funct3 {
                    0b000 => {
                        // sb
                        let base_offset = wrap_add(rs1_v, offset);
                        self.mem_set(base_offset, (rs2_v & 0b11111111).try_into().unwrap());
                    },
                    0b001 => {
                        // sh
                        // warning: little-endian
                        let base_offset = wrap_add(rs1_v, offset);
                        let b1: u8 = (rs2_v & 0b11111111).try_into().unwrap();
                        let b2: u8 = ((rs2_v & 0b1111111100000000) / 0b100000000)
                            .try_into()
                            .unwrap();
                        self.mem_set(base_offset, b1);
                        self.mem_set(wrap_add(base_offset, 1), b2);
                    },
                    0b010 => {
                        // sw
                        // warning: little-endian
                        let base_offset = wrap_add(rs1_v, offset);
                        let b1: u8 = (rs2_v & 0b11111111).try_into().unwrap();
                        let b2: u8 = ((rs2_v & 0b1111111100000000) / 0b100000000)
                            .try_into()
                            .unwrap();
                        let b3: u8 = ((rs2_v & 0b111111110000000000000000) / 0b10000000000000000)
                            .try_into()
                            .unwrap();
                        let b4: u8 = ((rs2_v & 0b11111111000000000000000000000000)
                            / 0b1000000000000000000000000)
                            .try_into()
                            .unwrap();
                        self.mem_set(base_offset, b1);
                        self.mem_set(wrap_add(base_offset, 1), b2);
                        self.mem_set(wrap_add(base_offset, 2), b3);
                        self.mem_set(wrap_add(base_offset, 3), b4);
                    },
                    0b011 => { return FlowControl::InvalidInstruction; },
                    0b100 => { return FlowControl::InvalidInstruction; },
                    0b101 => { return FlowControl::InvalidInstruction; },
                    0b110 => { return FlowControl::InvalidInstruction; },
                    0b111 => { return FlowControl::InvalidInstruction; },
                    _ => { return FlowControl::InvalidInstruction; },
                }
                self.pc = wrap_add(self.pc, 4);
            },
            0b01001 => { return FlowControl::InvalidInstruction; },
            0b01010 => { return FlowControl::InvalidInstruction; },
            0b01011 => { return FlowControl::InvalidInstruction; },
            0b01100 => {
                let funct7 = decode_funct7(instr);
                let funct3 = decode_funct3(instr);
                let (rd, rs1, rs2) = decode_rinstr(instr);
                let rs1_v = match self.get_r(rs1) {
                    Option::Some(v) => v,
                    Option::None => { return FlowControl::InvalidInstruction; },
                };
                let rs2_v = match self.get_r(rs2) {
                    Option::Some(v) => v,
                    Option::None => { return FlowControl::InvalidInstruction; },
                };
                let res = if funct7 == 0b0000000 && funct3 == 0b000 {
                    // add
                    wrap_add(rs1_v, rs2_v)
                } else if funct7 == 0b0100000 && funct3 == 0b000 {
                    // sub
                    wrap_sub(rs1_v, rs2_v)
                } else if funct7 == 0b0000000 && funct3 == 0b001 {
                    // sll
                    shl(rs1_v, rs2_v & 0b11111)
                } else if funct7 == 0b0000000 && funct3 == 0b010 {
                    // slt
                    if decode_signed(rs1_v) < decode_signed(rs2_v) {
                        1
                    } else {
                        0
                    }
                } else if funct7 == 0b0000000 && funct3 == 0b011 {
                    // sltu
                    if rs1_v < rs2_v {
                        1
                    } else {
                        0
                    }
                } else if funct7 == 0b0000000 && funct3 == 0b100 {
                    // xor
                    rs1_v ^ rs2_v
                } else if funct7 == 0b0000000 && funct3 == 0b101 {
                    // srl
                    shr(rs1_v, rs2_v & 0b11111)
                } else if funct7 == 0b0100000 && funct3 == 0b101 {
                    // sra
                    shrs(rs1_v, rs2_v & 0b11111)
                } else if funct7 == 0b0000000 && funct3 == 0b110 {
                    // or
                    rs1_v | rs2_v
                } else if funct7 == 0b0000000 && funct3 == 0b111 {
                    // and
                    rs1_v & rs2_v
                } else {
                    return FlowControl::InvalidInstruction;
                };
                if !self.set_r(rd, res) {
                    return FlowControl::InvalidInstruction;
                }
                self.pc = wrap_add(self.pc, 4);
            },
            0b01101 => {
                // lui
                let (rd, imm) = decode_uinstr(instr);
                if !self.set_r(rd, imm) {
                    return FlowControl::InvalidInstruction;
                }
                self.pc = wrap_add(self.pc, 4);
            },
            0b01110 => { return FlowControl::InvalidInstruction; },
            0b01111 => { return FlowControl::InvalidInstruction; },
            0b10000 => { return FlowControl::InvalidInstruction; },
            0b10001 => { return FlowControl::InvalidInstruction; },
            0b10010 => { return FlowControl::InvalidInstruction; },
            0b10011 => { return FlowControl::InvalidInstruction; },
            0b10100 => { return FlowControl::InvalidInstruction; },
            0b10101 => { return FlowControl::InvalidInstruction; },
            0b10110 => { return FlowControl::InvalidInstruction; },
            0b10111 => { return FlowControl::InvalidInstruction; },
            0b11000 => {
                // conditional branches
                let funct3 = decode_funct3(instr);
                let (rs1, rs2, imm) = decode_binstr(instr);
                let rs1_v = match self.get_r(rs1) {
                    Option::Some(v) => v,
                    Option::None => { return FlowControl::InvalidInstruction; },
                };
                let rs2_v = match self.get_r(rs2) {
                    Option::Some(v) => v,
                    Option::None => { return FlowControl::InvalidInstruction; },
                };
                match funct3 {
                    0b000 => {
                        // beq
                        if rs1_v == rs2_v {
                            self.pc = wrap_add(self.pc, sext13(imm));
                        } else {
                            self.pc = wrap_add(self.pc, 4);
                        }
                    },
                    0b001 => {
                        // bne
                        if rs1_v != rs2_v {
                            self.pc = wrap_add(self.pc, sext13(imm));
                        } else {
                            self.pc = wrap_add(self.pc, 4);
                        }
                    },
                    0b010 => { return FlowControl::InvalidInstruction; },
                    0b011 => { return FlowControl::InvalidInstruction; },
                    0b100 => {
                        // blt
                        if decode_signed(rs1_v) < decode_signed(rs2_v) {
                            self.pc = wrap_add(self.pc, sext13(imm));
                        } else {
                            self.pc = wrap_add(self.pc, 4);
                        }
                    },
                    0b101 => {
                        // bge
                        if decode_signed(rs1_v) >= decode_signed(rs2_v) {
                            self.pc = wrap_add(self.pc, sext13(imm));
                        } else {
                            self.pc = wrap_add(self.pc, 4);
                        }
                    },
                    0b110 => {
                        // bltu
                        if rs1_v < rs2_v {
                            self.pc = wrap_add(self.pc, sext13(imm));
                        } else {
                            self.pc = wrap_add(self.pc, 4);
                        }
                    },
                    0b111 => {
                        // bgeu
                        if rs1_v >= rs2_v {
                            self.pc = wrap_add(self.pc, sext13(imm));
                        } else {
                            self.pc = wrap_add(self.pc, 4);
                        }
                    },
                    _ => { return FlowControl::InvalidInstruction; },
                };
            },
            0b11001 => {
                // jalr
                let (rd, rs1, imm) = decode_iinstr(instr);
                let rs1_v = match self.get_r(rs1) {
                    Option::Some(v) => v,
                    Option::None => { return FlowControl::InvalidInstruction; },
                };
                let tmp = wrap_add(self.pc, 4);
                self.pc = wrap_add(rs1_v, sext12(imm)) & 0b11111111111111111111111111111110;
                if !self.set_r(rd, tmp) {
                    return FlowControl::InvalidInstruction;
                }
            },
            0b11010 => { return FlowControl::InvalidInstruction; },
            0b11011 => {
                // jal
                let (rd, imm) = decode_jinstr(instr);
                if !self.set_r(rd, wrap_add(self.pc, 4)) {
                    return FlowControl::InvalidInstruction;
                }
                self.pc = wrap_add(self.pc, sext21(imm));
            },
            0b11100 => {
                match decode_funct3(instr) {
                    0b000 => {
                        if instr == 0b00000_00_00000_00000_000_00000_11100_11 {
                            // ecall
                            return_v = FlowControl::ECall;
                        } else if instr == 0b00000_00_00001_00000_000_00000_11100_11 {
                            // ebreak
                            return_v = FlowControl::EBreak;
                        } else if instr == 0b00000_00_00010_00000_000_00000_11100_11 {
                            // uret
                            return_v = FlowControl::URet;
                        } else if instr == 0b00010_00_00010_00000_000_00000_11100_11 {
                            // sret
                            return_v = FlowControl::SRet;
                        } else if instr == 0b00110_00_00010_00000_000_00000_11100_11 {
                            // mret
                            return_v = FlowControl::MRet;
                        } else if instr == 0b00010_00_00101_00000_000_00000_11100_11 {
                            // wfi
                            return_v = FlowControl::Wfi;
                        } else if (instr
                            & 0b00010_01_00000_00000_000_00000_11100_11) == 0b00010_01_00000_00000_000_00000_11100_11 { // sfence.vma
                        // ignore for now
                        } else {
                            return FlowControl::InvalidInstruction;
                        }
                    },
                    0b001 => {
                        // csrrw
                        let (rd, rs1, csr) = decode_iinstr(instr);
                        let rs1_v = match self.get_r(rs1) {
                            Option::Some(v) => v,
                            Option::None => { return FlowControl::InvalidInstruction; },
                        };
                        let old_csr_value = match self.get_csr(csr) {
                            Option::Some(v) => v,
                            Option::None => { return FlowControl::InvalidInstruction; },
                        };
                        if !self.set_r(rd, old_csr_value) {
                            return FlowControl::InvalidInstruction;
                        }
                        if !self.set_csr(csr, rs1_v) {
                            return FlowControl::InvalidInstruction;
                        }
                    },
                    0b010 => {
                        // csrrs
                        let (rd, rs1, csr) = decode_iinstr(instr);
                        let rs1_v = match self.get_r(rs1) {
                            Option::Some(v) => v,
                            Option::None => { return FlowControl::InvalidInstruction; },
                        };
                        let old_csr_value = match self.get_csr(csr) {
                            Option::Some(v) => v,
                            Option::None => { return FlowControl::InvalidInstruction; },
                        };
                        if !self.set_r(rd, old_csr_value) {
                            return FlowControl::InvalidInstruction;
                        }
                        if !self.set_csr(csr, old_csr_value | rs1_v) {
                            return FlowControl::InvalidInstruction;
                        }
                    },
                    0b011 => {
                        // csrrc
                        let (rd, rs1, csr) = decode_iinstr(instr);
                        let rs1_v = match self.get_r(rs1) {
                            Option::Some(v) => v,
                            Option::None => { return FlowControl::InvalidInstruction; },
                        };
                        let old_csr_value = match self.get_csr(csr) {
                            Option::Some(v) => v,
                            Option::None => { return FlowControl::InvalidInstruction; },
                        };
                        if !self.set_r(rd, old_csr_value) {
                            return FlowControl::InvalidInstruction;
                        }
                        if !self.set_csr(csr, old_csr_value & ~rs1_v) {
                            return FlowControl::InvalidInstruction;
                        }
                    },
                    0b100 => { return FlowControl::InvalidInstruction; },
                    0b101 => {
                        // csrrwi
                        let (rd, rs1, csr) = decode_iinstr(instr);
                        let old_csr_value = match self.get_csr(csr) {
                            Option::Some(v) => v,
                            Option::None => { return FlowControl::InvalidInstruction; },
                        };
                        if !self.set_r(rd, old_csr_value) {
                            return FlowControl::InvalidInstruction;
                        }
                        if !self.set_csr(csr, rs1) {
                            return FlowControl::InvalidInstruction;
                        }
                    },
                    0b110 => {
                        // csrrsi
                        let (rd, rs1, csr) = decode_iinstr(instr);
                        let old_csr_value = match self.get_csr(csr) {
                            Option::Some(v) => v,
                            Option::None => { return FlowControl::InvalidInstruction; },
                        };
                        if !self.set_r(rd, old_csr_value) {
                            return FlowControl::InvalidInstruction;
                        }
                        if !self.set_csr(csr, old_csr_value | rs1) {
                            return FlowControl::InvalidInstruction;
                        }
                    },
                    0b111 => {
                        // csrrci
                        let (rd, rs1, csr) = decode_iinstr(instr);
                        let old_csr_value = match self.get_csr(csr) {
                            Option::Some(v) => v,
                            Option::None => { return FlowControl::InvalidInstruction; },
                        };
                        if !self.set_r(rd, old_csr_value) {
                            return FlowControl::InvalidInstruction;
                        }
                        if !self.set_csr(csr, old_csr_value & ~rs1) {
                            return FlowControl::InvalidInstruction;
                        }
                    },
                    _ => { return FlowControl::InvalidInstruction; },
                }
                self.pc = wrap_add(self.pc, 4);
            },
            0b11101 => { return FlowControl::InvalidInstruction; },
            0b11110 => { return FlowControl::InvalidInstruction; },
            0b11111 => { return FlowControl::InvalidInstruction; },
            _ => { return FlowControl::InvalidInstruction; },
        }

        return_v
    }

    // runs a program step (instruction)
    fn step(ref self: RISCVMachine) -> FlowControl {
        // check for program end
        if self.pc >= self.prog_end {
            return FlowControl::End;
        }

        // construct a full instruction from the pc (4 bytes)
        let instr1: u32 = self.mem_get(self.pc).into();
        let instr2: u32 = self.mem_get(wrap_add(self.pc, 1)).into();
        let instr3: u32 = self.mem_get(wrap_add(self.pc, 2)).into();
        let instr4: u32 = self.mem_get(wrap_add(self.pc, 3)).into();
        // little endian (MSB at highest address)
        let instr: u32 = instr4 * 0b1000000000000000000000000
            + instr3 * 0b10000000000000000
            + instr2 * 0b100000000
            + instr1;
        self.execute_instr(instr)
    }
}


fn main() -> u32 {
    0
}


#[cfg(test)]
mod tests {
    use super::RISCVMachineTrait;
    use super::ELFLoaderTrait;
    use super::FlowControl;


    #[test]
    fn memory_communication() {
        let mut elf_loader = ELFLoaderTrait::new();
        let mut machine = RISCVMachineTrait::new();

        // Below is the compiled version of the following program:

        //.global _start
        // 
        // _start:
        //     
        //     # run only one instance
        //     csrr    t0, mhartid
        //     bnez    t0, forever
        //     
        //     # prepare for the loop
        //     li      s1, 0x10000000  # output offset   
        //     la      s2, hello       # load string start addr into s2
        //     addi    s3, s2, 13      # set up string end addr in s3
        // 
        // loop:
        //     lb      s4, 0(s2)       # load next byte at s2 into s4
        //     sb      s4, 0(s1)       # write byte to output 
        //     addi    s2, s2, 1       # increase s2
        //     addi    s1, s1, 1       # increase s1
        //     blt     s2, s3, loop    # branch back until end addr (s3) reached
        // 
        // forever:
        //     wfi
        //     j       forever
        // 
        // 
        // .section .data
        // 
        // hello:
        //   .string "hello world!\n"
        let arr: Array<u8> = array![
            0x7F, 0x45, 0x4C, 0x46, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0xF3, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x34, 0x00, 0x00, 0x00, 0x8C, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x00, 0x20, 0x00, 0x01, 0x00, 0x28, 0x00, 0x05, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x42, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF3, 0x22, 0x40, 0xF1, 0x63, 0x94, 0x02, 0x02, 0xB7, 0x04, 0x00, 0x10, 0x17, 0x09, 0x00, 0x00, 0x13, 0x09, 0x89, 0x02, 0x93, 0x09, 0xD9, 0x00, 0x03, 0x0A, 0x09, 0x00, 0x23, 0x80, 0x44, 0x01, 0x13, 0x09, 0x19, 0x00, 0x93, 0x84, 0x14, 0x00, 0xE3, 0x48, 0x39, 0xFF, 0x73, 0x00, 0x50, 0x10, 0x6F, 0xF0, 0xDF, 0xFF, 0x68, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x21, 0x0A, 0x00, 0x41, 0x1D, 0x00, 0x00, 0x00, 0x72, 0x69, 0x73, 0x63, 0x76, 0x00, 0x01, 0x13, 0x00, 0x00, 0x00, 0x05, 0x72, 0x76, 0x33, 0x32, 0x69, 0x32, 0x70, 0x30, 0x00, 0x08, 0x01, 0x0A, 0x0B, 0x00, 0x2E, 0x73, 0x68, 0x73, 0x74, 0x72, 0x74, 0x61, 0x62, 0x00, 0x2E, 0x74, 0x65, 0x78, 0x74, 0x00, 0x2E, 0x64, 0x61, 0x74, 0x61, 0x00, 0x2E, 0x72, 0x69, 0x73, 0x63, 0x76, 0x2E, 0x61, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x10, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x80, 0x34, 0x10, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x10, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x10, 0x00, 0x00, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        ];
        let res = elf_loader.load(@arr, ref machine);
        assert_eq!(res, true);

        // run the machine
        loop {
            match machine.step() {
                FlowControl::Continue => {},
                FlowControl::End => {
                    println!("EOF");
                    break;
                },
                FlowControl::InvalidInstruction => {
                    println!("Invalid instruction");
                    break;
                },
                FlowControl::ECall => { println!("ECall"); },
                FlowControl::EBreak => { println!("EBreak"); },
                FlowControl::URet => { println!("URet"); },
                FlowControl::SRet => { println!("SRet"); },
                FlowControl::MRet => { println!("MRet"); },
                FlowControl::Wfi => {
                    // interrupt on wfi because that's how this perticular program signals that it finished
                    break;
                },
            };
        };

        // read the output registry
        let mut indx: u32 = 0x10000000;
        let mut res_string: ByteArray = "";
        loop {
            if indx == 0x10000000 + 13 {
                break;
            }
            let v = machine.mem_get(indx);
            res_string.append_byte(v);
            indx += 1;
        };
        println!("The RISC-V ELF was executed and sent the following output: {}", res_string);
        assert_eq!(res_string, "hello world!\n");
    }
}

